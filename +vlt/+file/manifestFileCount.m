function [folderList, childCounts] = manifestFileCount(fileList, isDir) % Added isDir input
%manifestFileCount Counts direct children within each directory from a manifest list.
%   [folderList, childCounts] = manifestFileCount(fileList, isDir) processes
%   a cell array of path strings and a corresponding logical vector
%   indicating directories (output from the 'manifest' function).
%   It returns a list of unique directories found and the count of *direct*
%   children (files OR subfolders) within each directory. Empty directories
%   listed in the input will be included with a count of 0.
%
%   Input Arguments:
%       fileList - Cell array of strings or string array, where each element
%                  is a path (relative or absolute) as generated by the
%                  'manifest' function. Must be sorted depth-first.
%       isDir    - Logical vector, same size as fileList. isDir(i) must be
%                  true if fileList(i) represents a directory, false otherwise.
%
%   Output Arguments:
%       folderList  - Cell array of strings containing the unique paths of
%                     directories found in fileList, preserving their first
%                     encountered order ('stable'). Includes empty directories.
%       childCounts - Numerical column vector of the same size as folderList,
%                     where childCounts(i) is the number of direct children
%                     (files OR folders) listed in fileList for the directory
%                     specified by folderList(i).
%
%   Example:
%       % Assume 'manifest' produced this:
%       myFileList = { ...
%           'DirA', ...             % isDir = true
%           'DirA/File1.txt', ...   % isDir = false
%           'DirA/SubDirA1', ...    % isDir = true
%           'DirA/SubDirA1/File2.txt', ... % isDir = false
%           'DirB', ...             % isDir = true (empty)
%           'DirC/File3.txt' ...    % isDir = false (DirC not listed explicitly if empty)
%       };
%       myIsDir = [true; false; true; false; true; false]; % DirB is empty
%
%       % If DirC was present in original scan but empty:
%       % myFileList = { ..., 'DirB', 'DirC'}; myIsDir = [..., true, true];
%
%       [folders, counts] = manifestFileCount(myFileList, myIsDir);
%       % Expected Output (based on first myFileList):
%       % folders = {'DirA'; 'DirA/SubDirA1'; 'DirB'}
%       % counts = [2; 1; 0] % DirA has File1.txt & SubDirA1; SubDirA1 has File2.txt; DirB has 0
%
%   See also: manifest, unique, startsWith, strsplit, cellfun, size

arguments
    fileList {mustBeA(fileList, ["cell", "string"]), mustBeVector}
    isDir    {mustBeA(isDir, ["logical", "double"]), mustBeVector, mustBeNumericOrLogical,mustBeEqualSize(fileList, isDir)} % Allow double 0/1 too
end

% Ensure input is a cell array of strings and logical vector for consistency
if isstring(fileList)
    fileList = cellstr(fileList);
end
isDir = logical(isDir); % Convert numeric 0/1 to logical false/true
fileList = fileList(:); % Ensure column vectors
isDir = isDir(:);

% --- Initialize Outputs ---
folderList = {};
childCounts = [];

% Handle empty input
if isempty(fileList)
    return;
end

% --- Step 1: Identify All Directories from Input ---
allDirsList = fileList(isDir); % Filter directly using the isDir input

% --- Step 2: Get Unique, Stable Folder List ---
if isempty(allDirsList)
    % No directories found based on isDir flag
    return;
else
    folderList = unique(allDirsList, 'stable'); % Keep first appearance order
end
folderList = folderList(:); % Ensure column

% --- Step 3: Prepare Depths ---
% Pre-calculate depths (number of path components) for all items
pathPartsFunc = @(p) strsplit(p, filesep);
nonEmptyPartsFunc = @(c) c(~cellfun('isempty',c));
lengthFunc = @(c) length(c);

try % Add try-catch for potentially large cellfun operations
    allPathParts = cellfun(pathPartsFunc, fileList, 'UniformOutput', false);
    allPathParts = cellfun(nonEmptyPartsFunc, allPathParts, 'UniformOutput', false);
    allDepths = cellfun(lengthFunc, allPathParts);

    folderPathParts = cellfun(pathPartsFunc, folderList, 'UniformOutput', false);
    folderPathParts = cellfun(nonEmptyPartsFunc, folderPathParts, 'UniformOutput', false);
    folderDepths = cellfun(lengthFunc, folderPathParts);
catch ME
    warning('Error calculating path depths: %s', ME.message);
    rethrow(ME); % Rethrow error after warning
end

% --- Step 4: Count Direct Children (Files or Folders) per Folder ---
childCounts = zeros(size(folderList)); % Initialize counts

for f = 1:numel(folderList) % Iterate through each unique folder identified
    currentFolder = folderList{f};
    currentFolderDepth = folderDepths(f);
    % Define the prefix required for children of this folder
    childPrefix = [currentFolder filesep];

    % Check all items in the original list to see if they are direct children
    for i = 1:numel(fileList)
        item = fileList{i};
        itemDepth = allDepths(i);

        % Check 1: Is it potentially a child (starts with folder prefix)?
        if startsWith(item, childPrefix)
            % Check 2: Is it a *direct* child (depth is exactly one more)?
            if itemDepth == (currentFolderDepth + 1)
                % If it passes both checks, it's a direct child (file OR folder)
                childCounts(f) = childCounts(f) + 1;
            end
        end
    end % End loop through fileList items
end % End loop through folders

end % function manifestFileCount


% --- Local function for argument validation ---
function mustBeEqualSize(a,b)
% Test for equal size
    if ~isequal(size(a), size(b))
        eid = 'Size:notEqual';
        msg = 'Inputs fileList and isDir must have the same size.';
        throwAsCaller(MException(eid,msg))
    end
end