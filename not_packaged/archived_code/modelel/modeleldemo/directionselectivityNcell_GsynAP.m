function GsynAP = directionselectivityNcell_GsynAP(searchrange, sizeinputs, response, weight, direction, varargin)
% INTFIRELEAKY_GSYNAP - Empirically determine minimum synaptic strength for AP
%
%   GSYNAP=DIRECTIONSELECTIVITYNCELL_GSYNAP(SEARCHRANGE, SIZEINPUTS, RESPONSE, WEIGHT, DIR, PARAM1, VALUE1, ...);
%
%   Determine minimum conducance necessary to generate RESPONSE action potentials
%   in a single sweep over a model generated by DIRECTIONSELECTIVITYNCELLDEMO.
%   By default, RESPONSE is 1.
%
%   The variable SEARCHRANGE = [ MIN MAX STEPS ] specifies the search domain.
%   The conductance values will be searched between MIN and MAX in a
%   binary search fashion of STEPS number of steps.  (Default: [0 10e-9 30])
%
%   SIZEINPUTS is the dimension of the inputs ([N R]). By default, SIZEINPUTS is [2 2].
%
%   WEIGHT is a matrix the same size as SIZEINPUTS that will be used to weight the
%   GsynAP across the network. Default value is a matrix the size
%   of SIZEINPUTS that is all 1's. One could specify TRUI(ONES(N,R)) to specify that only
%   the upper triangle of the inputs should be connected.
%
%   DIR is 0 for 'up', 1 for 'down'. (default 0)
%
%   If empty ([]) is passed for any of the inputs, then the defaults will be used.
%
%   Examples:
%    % using default parameters:
%    GsynAP = directionselectivityNcell_GsynAP([],[2 2],[],[]); % use defaults
% 
%    GsynAP = directionselectivityNcell_GsynAP([],[5 5],[],[],'N',5,'R',5,'isi',2);
% 
%
%   See also: DIRECTIONSELECTIVITYNCELLDEMO

if isempty(searchrange),
	searchrange = [0 10e-9 30];
end;
if isempty(response),
	response=1 ;
end;
if isempty(weight),
	weight = ones(sizeinputs);
end;
if isempty(direction),
	direction = 0;
end;

 % test both bounds

GsynAP = doactualsearch(searchrange(3),searchrange(1:2),[NaN NaN],sizeinputs,response,weight,direction,varargin{:});

%%%%%%%%%%%%%%%%%%%%%%

function Gsyn_estimate = doactualsearch(searchsteps,B,bstatus,sizeinputs,response,weight,direction,varargin)  % B is bounds

 % B comes in as a 2 element vector, becomes a 3. B(1) is lower bound, B(2) is upper bound, B(3) is middle
 % bstatus - is this point above threshold? 
B(3) = mean(B(1:2)); % midpoint
bstatus(3) = NaN; % we don't know if it is above or below threshold

if searchsteps>0,
	for n=1:3,
		% make sure both bounds are tested
		if isnan(bstatus(n)), % need to test bound
			if direction==0,
				dir_not_to_do_str = 'simdown';
			else,
				dir_not_to_do_str = 'simup';
			end;
			[dummy,dummy2,r_up,r_down] = directionselectivityNcelldemo(varargin{:}, dir_not_to_do_str,0,...
				'Syn_Gmax_initial',B(n)*weight(:)');
			if direction==0,
				resp = r_up;
			else,
				resp = r_down;
			end;
			if resp>=response,
				Bnext(n) = 1; % this is suprathreshold
			else,
				Bnext(n) = -1; % this is subthreshold
			end;
		else,
			Bnext(n) = bstatus(n);
		end;
	end;
	if all(Bnext(1:2)<0), % our search failed, both bounds are below threshold
		error(['Both suggested bounds are below threshold']); % more help
	end;
	if all(Bnext(1:2)>0), % our search failed, both bounds are below threshold
		error(['Both suggested bounds are above threshold']); % more help
	end;
	% now we know Bnext(1) is below threshold, Bnext(2) is above; what is Bnext(3)?
	if Bnext(3)<0,
		Gsyn_estimate = doactualsearch(searchsteps-1,[B(3) B(2)],[Bnext(3) Bnext(2)],sizeinputs,response,weight,direction,varargin{:});
	else,
		Gsyn_estimate = doactualsearch(searchsteps-1,[B(1) B(3)],[Bnext(1) Bnext(3)],sizeinputs,response,weight,direction,varargin{:});
	end;
else,
	Gsyn_estimate = max(B(1:2)); % must return something above threshold
	return;
end;


